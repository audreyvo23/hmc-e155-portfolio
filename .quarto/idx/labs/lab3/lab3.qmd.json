{"title":"Lab 3: Keypad Scanner","markdown":{"yaml":{"title":"Lab 3: Keypad Scanner","author":"Audrey Vo","date":"9/16/24"},"headingText":"Main Goals","containsRefs":false,"markdown":"\n\nNumber of Hours Spent on Lab: 30 hours\n\n[GitHub Lab 3 Files](https://github.com/audreyvo23/e155-lab3)\n\n\nThe main goals of this lab were to use design and implement and circuit interface on the FPGA that read a keypad matrix. This required creating a solution to address issues that arose from switch bouncing. Finally, the last 2 inputted digits needed to be displayed on a pair of 7 segment LED displays. \n\n## Design Approach\n\n### FSM Design\nIn order to detect which row and column were turned on during a button pressed, all of the rows could not be turned on at once because then several keys would be viewed as on with a single button press. Thus, the idea was to scan through the rows during each clock cycle, and then take the columns as an input to the FPGA. Whenever a column is detected on, the FPGA can then figure out which row was powered on that time and then decode the corresponding key value. \n\nAn FSM was created to keep track of all of the states. States 0, 1, 2, and 3 are cycled through when the button is off, until a button is turned on. The button is turned on when any of the column inputs are detected to be on. When a button is turned on, the next state will be a separate state (represented by States 4, 6, 8, 10) that will be stayed at for one clock cycle. The enable is represented when any of these states are turned on, because it will be used later to track when the digits on the keypad need to be shifted. Finally, after the button is pressed, if it is still being pressed or held down after the first clock cycle, it will be moved to a holding state represented by States 5, 7, 9, and 11. \nIn addition, only one button click should be detected, which is why these states exist, and the program will stay on these states until the button is turned off. \n\n::: {#tbl-panel layout-ncol=3}\n| Current State | \n|---------------|\n| S0            |\n| S1            | \n| S2            | \n| S3            |\n| S4            | \n| S5            | \n| S6            |\n| S7            | \n| S8            | \n| S9            |\n| S10           | \n| S11           | \n\n: Current State {#tbl-third}\n\n| B = 1 | B = 0 |\n|-------|-------|\n| S10   | S1    | \n| S4    | S2    | \n| S6    | S3    | \n| S8    | S0    | \n| S5    | S1    | \n| S5    | S1    | \n| S7    | S2    | \n| S7    | S2    |\n| S9    | S3    | \n| S9    | S3    |  \n| S11   | S0    | \n| S11   | S0    |  \n\n: Next State {#tbl-first}\n\n| B = 1         |\n|-------|-------|\n| R0 = 1|       | \n| R1 = 1|       | \n| R2 = 1|       | \n| R3 = 1|       | \n| R1 = 1|en = 1 |\n| R1 = 1|       |\n| R2 = 1|en = 1 |\n| R2 = 1|       |\n| R3 = 1|en =  1|\n| R3 = 1|       |\n| R0 = 1|en = 1|\n| R0 = 1|       |\n\n: Output {#tbl-second}\n\nState Transition Table\n:::\n\n//See @tbl-panel for details, especially @tbl-second.\n\n\n\n\n\n![FSM Diagram for the Key Scanner](images/lab3fsm.png)\n\n### System Verilog Design\nThe System Verilog code created consisted of an internal high speed oscillator at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. This same clock was also used for the keypad_scanner, two_digit_mem, and selector_checker. \n\nThe keypad_scanner submodule took in the column inputs of the physical keypad and outputted an 8 bit value that represented which rows and columns were turned on at each clock cycle. A counter was also outputted that counted for 50 clock cycles to represent what values should count as an actual button press as opposed to switch bouncing. Finally, an enable was also outputted that represented when each button was turned in the form of one clock cycle.\n\nThe 8 bit value outputted from the keypad_scanner was then inputted to another submodule known as keypad_decoder taht return a 4 bit value representing the desired hex value that should be displayed on the seven segment display. \n\nIn order to shift the key values properly to display the last 2 values pressed on the keypad, a shifting submodule was created. This submodule would shift the key values at every clock edge only if the enable was high (button is on for exactly one clock cycle) and if the counter was greater than 50 clock cycles. This ensured that there was no switch bouncing and also that the the keypad values were be shifted for only one clock cycle. This submodule would then output the two desired hex values that should be displayed on the seven segment display.\n\nSystem Verilog code for how the two values were displayed on the sevenSeg were used from Lab 2. \n\n![Block diagram of System Verilog Modules](images/lab3block.diagram.png)\n\n### 7 Segment and Transistor Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode's current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor's output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n### Keypad Circuit Design\nThe keypad consisted of 8 pins that powered the 4 rows and 4 columns. The 4 column were connected as inputs to the FPGA. They all required pull-down resistor values in order to ensure that the input was not floating. This resistor value was calculated in order to minimize the current flow to about 1.2 mA. As a result, the resistors used for the circuit are all 2.7 kOhms. \n\n![Calculations to solve for pull-down resistor value](images/pulldownresistor.png)\n\nIn addition, the 4 pins connected to the rows of the keypad acted as direct inputs to the FPGA.\n\n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the 7-segment display and keypad pins. The column variables (C0, C1, C2, C3), reset, row variables (R0, R1, R2, R3), selectors, and 7 segment values (seg) defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable       | pin # |\n|----------------|:------|\n| seg[0]         |   47  |  \n| seg[1]         |   2   |\n| seg[2]         |   13  |  \n| seg[3]         |   20  |\n| seg[4]         |   18  |  \n| seg[5]         |   12  |\n| seg[6]         |   48  |\n| selector1      |   6   |\n| selector2      |   4   |\n| C0             |   45  |\n| C1             |   10  |  \n| C2             |   19  |\n| C3             |   21  |  \n| R0             |   44  |\n| R1             |   46  |\n| R2             |   9   |\n| R3             |   11  |\n| reset          |   34  |\n\n: Pin assignment to System Verilog variables\n\n\n![Physical Circuit Schematic for Entire System](images/lab3schematic.png)\n\n### Tradeoffs of Chosen Design\nThe design I created involved creating a lot of modules for each of the design's functions. This made it easy for me to test and debug each module individually, and also understand the process flow of the circuit design. However, when I was testing the modules all together, I had a lot of difficulty tracking down which module the issue would arise in because there were a lot of internal variables being passed through each module.\n\nAnother design choice I made was the FSM design. The FSM design was intuitive because it used a lot of the concepts we used in class such as how to get a pulse for only one clock cycle. I also understood what was happening the FSM, so it was easier for me to implement in System Verilog. However, when I was trying to implement debouncing later, it was difficult to do so within the existing FSM, since that FSM was already fully set. Thus, I was trying to create a debouncing system that did not affect or further complicate the current FSM implemented. This definitely caused some difficulty because of the design constraints. \n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules's functionality. \n\n### Keypad Scanner Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 10 timesteps. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 2000 ns. At random times, one of the column inputs would be forced to 1. When looking at the output of the testbench in the Wave view, it shows the rows rotating on high every clock cycle until a column is turned on high. When the column is high, the value of the row it is set on will stay high as expected. Thus, the keypad_val outputting at this point is a combination of the columns and rows that are high. \n\n![Testbench output for Keypad Scanner](images/keypadscannertb.png)\n\n### Keypad Decoder Testing\nIn order to check if the keypad decoder function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the keypad decoder function. At the start of the simulation, input values for the keypad decoder reflecting which rows and columns were currently on. The waveforms could then be observed of the output to ensure it shows the expected binary output based on the row and column inputs.\n\n![Testbench output for Keypad Decoder module](images/keypaddecodertb.png)\n\n### Two Digit Memory Testing\nIn order to check if the two digit memory function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the two digit memory function. At the start of the simulation, input values for the input switch were set to various values. Some were held for less than 50 clock cycles, while others were held for longer than 50 clock cycles. The two digit memory was supposed to take care of switch bouncing, so the waveform should show the output s1 and s2 values only capturing and switching values when the input s is held for longer than 50 clock cycles. This behavior was observed in the waveforms. Thus, the module behaved as expected.\n\n![Testbench output for Two Digit Memory module](images/shiftertb.png)\n\n### Top Module\nBefore transferring all of the code to Radiant Software, a final testbench was created for the top module that tested all of the submodules together. A dut was instantiated with the column inputs and expected output being held at various values. At one point, one of the column inputs were held for less than 50 clock cycles to test switch bouncing. The output of this waveform was the expected seven Segment output pins in binary. In the waveform, it can be seen that there are two values oscillating as expected to reflect the keypad input simulated.\n\n![Testbench output for the Top Level module](images/toptb.png)\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\nNumber of Hours Spent on Lab: 30 hours\n\n[GitHub Lab 3 Files](https://github.com/audreyvo23/e155-lab3)\n\n\n## Main Goals\nThe main goals of this lab were to use design and implement and circuit interface on the FPGA that read a keypad matrix. This required creating a solution to address issues that arose from switch bouncing. Finally, the last 2 inputted digits needed to be displayed on a pair of 7 segment LED displays. \n\n## Design Approach\n\n### FSM Design\nIn order to detect which row and column were turned on during a button pressed, all of the rows could not be turned on at once because then several keys would be viewed as on with a single button press. Thus, the idea was to scan through the rows during each clock cycle, and then take the columns as an input to the FPGA. Whenever a column is detected on, the FPGA can then figure out which row was powered on that time and then decode the corresponding key value. \n\nAn FSM was created to keep track of all of the states. States 0, 1, 2, and 3 are cycled through when the button is off, until a button is turned on. The button is turned on when any of the column inputs are detected to be on. When a button is turned on, the next state will be a separate state (represented by States 4, 6, 8, 10) that will be stayed at for one clock cycle. The enable is represented when any of these states are turned on, because it will be used later to track when the digits on the keypad need to be shifted. Finally, after the button is pressed, if it is still being pressed or held down after the first clock cycle, it will be moved to a holding state represented by States 5, 7, 9, and 11. \nIn addition, only one button click should be detected, which is why these states exist, and the program will stay on these states until the button is turned off. \n\n::: {#tbl-panel layout-ncol=3}\n| Current State | \n|---------------|\n| S0            |\n| S1            | \n| S2            | \n| S3            |\n| S4            | \n| S5            | \n| S6            |\n| S7            | \n| S8            | \n| S9            |\n| S10           | \n| S11           | \n\n: Current State {#tbl-third}\n\n| B = 1 | B = 0 |\n|-------|-------|\n| S10   | S1    | \n| S4    | S2    | \n| S6    | S3    | \n| S8    | S0    | \n| S5    | S1    | \n| S5    | S1    | \n| S7    | S2    | \n| S7    | S2    |\n| S9    | S3    | \n| S9    | S3    |  \n| S11   | S0    | \n| S11   | S0    |  \n\n: Next State {#tbl-first}\n\n| B = 1         |\n|-------|-------|\n| R0 = 1|       | \n| R1 = 1|       | \n| R2 = 1|       | \n| R3 = 1|       | \n| R1 = 1|en = 1 |\n| R1 = 1|       |\n| R2 = 1|en = 1 |\n| R2 = 1|       |\n| R3 = 1|en =  1|\n| R3 = 1|       |\n| R0 = 1|en = 1|\n| R0 = 1|       |\n\n: Output {#tbl-second}\n\nState Transition Table\n:::\n\n//See @tbl-panel for details, especially @tbl-second.\n\n\n\n\n\n![FSM Diagram for the Key Scanner](images/lab3fsm.png)\n\n### System Verilog Design\nThe System Verilog code created consisted of an internal high speed oscillator at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. This same clock was also used for the keypad_scanner, two_digit_mem, and selector_checker. \n\nThe keypad_scanner submodule took in the column inputs of the physical keypad and outputted an 8 bit value that represented which rows and columns were turned on at each clock cycle. A counter was also outputted that counted for 50 clock cycles to represent what values should count as an actual button press as opposed to switch bouncing. Finally, an enable was also outputted that represented when each button was turned in the form of one clock cycle.\n\nThe 8 bit value outputted from the keypad_scanner was then inputted to another submodule known as keypad_decoder taht return a 4 bit value representing the desired hex value that should be displayed on the seven segment display. \n\nIn order to shift the key values properly to display the last 2 values pressed on the keypad, a shifting submodule was created. This submodule would shift the key values at every clock edge only if the enable was high (button is on for exactly one clock cycle) and if the counter was greater than 50 clock cycles. This ensured that there was no switch bouncing and also that the the keypad values were be shifted for only one clock cycle. This submodule would then output the two desired hex values that should be displayed on the seven segment display.\n\nSystem Verilog code for how the two values were displayed on the sevenSeg were used from Lab 2. \n\n![Block diagram of System Verilog Modules](images/lab3block.diagram.png)\n\n### 7 Segment and Transistor Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode's current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor's output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n### Keypad Circuit Design\nThe keypad consisted of 8 pins that powered the 4 rows and 4 columns. The 4 column were connected as inputs to the FPGA. They all required pull-down resistor values in order to ensure that the input was not floating. This resistor value was calculated in order to minimize the current flow to about 1.2 mA. As a result, the resistors used for the circuit are all 2.7 kOhms. \n\n![Calculations to solve for pull-down resistor value](images/pulldownresistor.png)\n\nIn addition, the 4 pins connected to the rows of the keypad acted as direct inputs to the FPGA.\n\n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the 7-segment display and keypad pins. The column variables (C0, C1, C2, C3), reset, row variables (R0, R1, R2, R3), selectors, and 7 segment values (seg) defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable       | pin # |\n|----------------|:------|\n| seg[0]         |   47  |  \n| seg[1]         |   2   |\n| seg[2]         |   13  |  \n| seg[3]         |   20  |\n| seg[4]         |   18  |  \n| seg[5]         |   12  |\n| seg[6]         |   48  |\n| selector1      |   6   |\n| selector2      |   4   |\n| C0             |   45  |\n| C1             |   10  |  \n| C2             |   19  |\n| C3             |   21  |  \n| R0             |   44  |\n| R1             |   46  |\n| R2             |   9   |\n| R3             |   11  |\n| reset          |   34  |\n\n: Pin assignment to System Verilog variables\n\n\n![Physical Circuit Schematic for Entire System](images/lab3schematic.png)\n\n### Tradeoffs of Chosen Design\nThe design I created involved creating a lot of modules for each of the design's functions. This made it easy for me to test and debug each module individually, and also understand the process flow of the circuit design. However, when I was testing the modules all together, I had a lot of difficulty tracking down which module the issue would arise in because there were a lot of internal variables being passed through each module.\n\nAnother design choice I made was the FSM design. The FSM design was intuitive because it used a lot of the concepts we used in class such as how to get a pulse for only one clock cycle. I also understood what was happening the FSM, so it was easier for me to implement in System Verilog. However, when I was trying to implement debouncing later, it was difficult to do so within the existing FSM, since that FSM was already fully set. Thus, I was trying to create a debouncing system that did not affect or further complicate the current FSM implemented. This definitely caused some difficulty because of the design constraints. \n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules's functionality. \n\n### Keypad Scanner Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 10 timesteps. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 2000 ns. At random times, one of the column inputs would be forced to 1. When looking at the output of the testbench in the Wave view, it shows the rows rotating on high every clock cycle until a column is turned on high. When the column is high, the value of the row it is set on will stay high as expected. Thus, the keypad_val outputting at this point is a combination of the columns and rows that are high. \n\n![Testbench output for Keypad Scanner](images/keypadscannertb.png)\n\n### Keypad Decoder Testing\nIn order to check if the keypad decoder function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the keypad decoder function. At the start of the simulation, input values for the keypad decoder reflecting which rows and columns were currently on. The waveforms could then be observed of the output to ensure it shows the expected binary output based on the row and column inputs.\n\n![Testbench output for Keypad Decoder module](images/keypaddecodertb.png)\n\n### Two Digit Memory Testing\nIn order to check if the two digit memory function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the two digit memory function. At the start of the simulation, input values for the input switch were set to various values. Some were held for less than 50 clock cycles, while others were held for longer than 50 clock cycles. The two digit memory was supposed to take care of switch bouncing, so the waveform should show the output s1 and s2 values only capturing and switching values when the input s is held for longer than 50 clock cycles. This behavior was observed in the waveforms. Thus, the module behaved as expected.\n\n![Testbench output for Two Digit Memory module](images/shiftertb.png)\n\n### Top Module\nBefore transferring all of the code to Radiant Software, a final testbench was created for the top module that tested all of the submodules together. A dut was instantiated with the column inputs and expected output being held at various values. At one point, one of the column inputs were held for less than 50 clock cycles to test switch bouncing. The output of this waveform was the expected seven Segment output pins in binary. In the waveform, it can be seen that there are two values oscillating as expected to reflect the keypad input simulated.\n\n![Testbench output for the Top Level module](images/toptb.png)\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Lab 3: Keypad Scanner","author":"Audrey Vo","date":"9/16/24"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}