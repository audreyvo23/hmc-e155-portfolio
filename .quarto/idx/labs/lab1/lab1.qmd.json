{"title":"Lab 1: FPGA and MCU Setup and Testing","markdown":{"yaml":{"title":"Lab 1: FPGA and MCU Setup and Testing","author":"Audrey Vo","date":"9/2/24"},"headingText":"Main Goals","containsRefs":false,"markdown":"\nNumber of Hours Spent on Lab: 14 hours\n\nThe main goals of this lab was to assemble the development board and test out the MCU and FPGA boards. In addition, an FPGA design was created in System Verilog to control 3 LEDs on the board and a 7-segement display. The LEDs and 7-segement display behavior is based on input of the switches on the board. As a result, the 7-segment display needed to be interfaced to the FPGA board in order to work as desired. \n\n## Design Approach\n\n### LED Design\nIn order to design the project so that the LEDs worked properly, I recognized that one of the led[1] is controlled by an AND gate and the second led[0] is controlled by an XOR gate of the switch values. Led[2] needed to blink at 2.4 Hz using an internal high-speed oscillator. By using the starter code provided in the fpga_dev_board_test file, a new maximum counter value needed to be calculated. Since the internal oscillator is running at 48 MHz, we get the number of counts to be 10M to get an led blinking at 2.4 MHz assuming we want a 50% duty cycle. An additional variable needed to be created in order to check if the led should be turned on or off every time the counter gets to 10M. \n\n![Calculation to find the number of counts](images/counts.jpg)\n\n### 7 Segment Display Design\nIn order to design the 7-segment display, I had to use a series of case statement for the 16 different outputs to be displayed based on the switches in a separate submodule. It was important to set pin 3 on the display to the 3.3 V so that it is always on. Thus, the segement's cathode will turn the segement on when it is set to 0. Each case statement set the output segement values to 0 when that segement should be turned on based on what binary value was currently set on the input switches. This code was written in a separate file but was called in the same file that controlled the 3 Leds. In order to wire the 7-segment display, the various pins that controlled the display were connected to the FPGA board using 240 Ohm resistors in order to achieve 10 mA of current. \n\n![Calculation to find the resistor value for the 7 segement display](images/resistor.jpg)\n\n\n![Block Diagram of System Verilog module](images/lab1blockdiagram.png)\n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable| pin # |\n|---------|:------|\n| s[0]    |   37  |   \n| s[1]    |   31  |  \n| s[2]    |   35  |\n| s[3]    |   32  |  \n| led[0]  |   42  |   \n| led[1]  |   38  |  \n| led[2]  |   28  | \n| seg[0]  |   47  |  \n| seg[1]  |   2   |\n| seg[2]  |   13  |  \n| seg[3]  |   20  |\n| seg[4]  |   18  |  \n| seg[5]  |   12  |\n| seg[6]  |   48  |\n\n: Pin assignment to System Verilog variables\n\n![Full schematic with Led, Switch, and 7-segment display pin connections](images/schematic.png)\n\n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. The values of input s can be forced to any binary combination, and the output from the code could be seen in the Wave view. Upon doing so, I could see that the output I was receving from the forced inputs were the desired values. A testbench was also created to check that there were no errors in my logic.\n\nFinally, I uploaded the code to my FPGA board, which was also connected to the 7-segment display through a ribbon cable. After toggling with the physical input switches, the desired led behavior and 7-segment display was shown. I also used an oscilloscope to measure the frequency of the third led to ensure it had the desired frequency of 2.4 Hz. \n\n![Testbench output for the circuit](images/testbench.png)\n\n\n## Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements.\n\n\n\n\n","srcMarkdownNoYaml":"\nNumber of Hours Spent on Lab: 14 hours\n\n## Main Goals\nThe main goals of this lab was to assemble the development board and test out the MCU and FPGA boards. In addition, an FPGA design was created in System Verilog to control 3 LEDs on the board and a 7-segement display. The LEDs and 7-segement display behavior is based on input of the switches on the board. As a result, the 7-segment display needed to be interfaced to the FPGA board in order to work as desired. \n\n## Design Approach\n\n### LED Design\nIn order to design the project so that the LEDs worked properly, I recognized that one of the led[1] is controlled by an AND gate and the second led[0] is controlled by an XOR gate of the switch values. Led[2] needed to blink at 2.4 Hz using an internal high-speed oscillator. By using the starter code provided in the fpga_dev_board_test file, a new maximum counter value needed to be calculated. Since the internal oscillator is running at 48 MHz, we get the number of counts to be 10M to get an led blinking at 2.4 MHz assuming we want a 50% duty cycle. An additional variable needed to be created in order to check if the led should be turned on or off every time the counter gets to 10M. \n\n![Calculation to find the number of counts](images/counts.jpg)\n\n### 7 Segment Display Design\nIn order to design the 7-segment display, I had to use a series of case statement for the 16 different outputs to be displayed based on the switches in a separate submodule. It was important to set pin 3 on the display to the 3.3 V so that it is always on. Thus, the segement's cathode will turn the segement on when it is set to 0. Each case statement set the output segement values to 0 when that segement should be turned on based on what binary value was currently set on the input switches. This code was written in a separate file but was called in the same file that controlled the 3 Leds. In order to wire the 7-segment display, the various pins that controlled the display were connected to the FPGA board using 240 Ohm resistors in order to achieve 10 mA of current. \n\n![Calculation to find the resistor value for the 7 segement display](images/resistor.jpg)\n\n\n![Block Diagram of System Verilog module](images/lab1blockdiagram.png)\n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable| pin # |\n|---------|:------|\n| s[0]    |   37  |   \n| s[1]    |   31  |  \n| s[2]    |   35  |\n| s[3]    |   32  |  \n| led[0]  |   42  |   \n| led[1]  |   38  |  \n| led[2]  |   28  | \n| seg[0]  |   47  |  \n| seg[1]  |   2   |\n| seg[2]  |   13  |  \n| seg[3]  |   20  |\n| seg[4]  |   18  |  \n| seg[5]  |   12  |\n| seg[6]  |   48  |\n\n: Pin assignment to System Verilog variables\n\n![Full schematic with Led, Switch, and 7-segment display pin connections](images/schematic.png)\n\n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. The values of input s can be forced to any binary combination, and the output from the code could be seen in the Wave view. Upon doing so, I could see that the output I was receving from the forced inputs were the desired values. A testbench was also created to check that there were no errors in my logic.\n\nFinally, I uploaded the code to my FPGA board, which was also connected to the 7-segment display through a ribbon cable. After toggling with the physical input switches, the desired led behavior and 7-segment display was shown. I also used an oscilloscope to measure the frequency of the third led to ensure it had the desired frequency of 2.4 Hz. \n\n![Testbench output for the circuit](images/testbench.png)\n\n\n## Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements.\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Lab 1: FPGA and MCU Setup and Testing","author":"Audrey Vo","date":"9/2/24"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}