{"title":"Lab 2: Multiplexed 7-Segment Display","markdown":{"yaml":{"title":"Lab 2: Multiplexed 7-Segment Display","author":"Audrey Vo","date":"9/9/2024"},"headingText":"Main Goals","containsRefs":false,"markdown":"\n\nNumber of Hours Spent on Lab: 11 hours\n\nThe main goals of this lab were to use a time-multiplexing schematic to drive 2 separate 7 segement LED displays with a single set of pins on the FPGA and Verilog code. In addition, a transistor was required to use in order to drive larger currents from the FPGA pins to power the LED displays. An additional LED display was also used to report the sum of the 2 7 segement LED displays in binary format. Finally, a function testbench needed to be created in ModelSim to test the System Verilog code and ensure that each of the modules created worked as expected.\n\n## Design Approach\n\n### System Verilog Design\nThe System Verilog code created consisted of an oscillator submodule that would return alternating values used to turn the transistors on and off. This submodule utilized an internal high speed oscillator running at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. These alternating bits are inputed into a mux that will output the desired switch input used between the two switch inputs assigned to the board. This desired switch input will then be fed into the sevenSeg display code used in Lab 1 that will output the desired values to the 7 segment displays. \n\n![Block diagram of System Verilog Modules](images/lab2blockdiagram.png)\n\n### 7 Segment Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode's current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor's output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n\n![Calculation to find the resistor value for the 7 segment display](images/resistor.png)\n\n### Transistor Circuit Design\nBecause the LED display used was a common anode display, a PNP transistor was needed in order to drive the current high. The emitter of the circuit was connected to the FPGA pin that oscillated between low and high values determining whether or not the circuit was turned on. When values were low, current from the base voltage would be high and flow through the LED load to turn it on. A base resistor was needed to connect the 3.3 V to the base of the transistor so that not too much current is drawn from the FPGA pins. The calculated resistor value needed for the base was 130 Ohms, but 150 Ohms was used instead since that was readily available from the stockroom.\n\n\n![Calculation to find the resistor value for the transistor](images/transistor.png)\n\n### LED Sum Circuit Design\nThe LED display used was grounded with 220 Ohm resistors for the same reason the seven segment display was. The input of this circuit was the output of combinational logic written in System Verilog. \n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable       | pin # |\n|----------------|:------|\n| s1[0]          |   37  |   \n| s1[1]          |   31  |  \n| s1[2]          |   35  |\n| s1[3]          |   32  | \n| s2[0]          |   11  |   \n| s2[1]          |   19  |  \n| s2[2]          |   21  |\n| s2[3]          |   10  |  \n| ledDisplay[0]  |   46  |   \n| ledDisplay[1]  |   45  |  \n| ledDisplay[2]  |   3   | \n| ledDisplay[3]  |   44  |  \n| ledDisplay[4]  |   9   | \n| seg[0]         |   47  |  \n| seg[1]         |   2   |\n| seg[2]         |   13  |  \n| seg[3]         |   20  |\n| seg[4]         |   18  |  \n| seg[5]         |   12  |\n| seg[6]         |   48  |\n| selector1      |   6   |\n| selector2      |   4   |\n\n: Pin assignment to System Verilog variables\n\n\n![Physical Circuit Schematic for Entire System](images/lab2schematic.jpg)\n\n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules's functionality. \n\n### Oscillator Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 1 timestep. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 1 M ns. When looking at the output of the testbench in the Wave view, it shows that the output of the oscillator changes value every 10000 ns, while the internal clock is oscillating at a much faster rate as expected.\n\n![Testbench output for Oscillator module](images/osctb.png)\n\n### Mux Testing\nIn order to check if the mux function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the mux function. At the start of the simulation, input values for switch inputs 1 and 2 were set to 8 and 0 respectively. A selector was then set to 1 so that the first switch value was chosen. A separate variable containing the expected output was created so that it can be compared with the output of the mux. After 2 more clock signals, the selector's value was changed to 0 so that the output of the mux is changed as well. In the simulation's Wave view, the output of the mux (s) and the expected value of the mux (s_expected) match each other's values.\n\n![Testbench output for Mux module](images/muxtb.png)\n\n### Sum Testing\nIn order to check if the sum function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for switch 1 and 2 were set to various values, along with a new variable that was the expected sum of the two switch inputs. After running the simulation for 2 clock signals, the input values of the switches and the expected sum were updated to different values. In the simulation's Wave view, it can be seen that the expected sum value matched the output of the sum module as desired. Thus, the module behaved as expected.\n\n![Testbench output for Sum module](images/sumtb.png)\n\n### Seven Segment Display Testing\nIn order to check if the Seven Segement display function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for the switch were set to various values. The expected segment display were also set. After running the simulation for 2 clock signals, the input values of the switch and the expected output were updated to different values. In the simulation's Wave view, it can be seen that the expected display value matched the output of the sevenSeg module as desired. Thus, the module behaved as expected.\n\n![Testbench output for Seven Segment Display module](images/sevenSegtb.png)\n\n\n## Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements.\n\n\n\n\n","srcMarkdownNoYaml":"\n\nNumber of Hours Spent on Lab: 11 hours\n\n## Main Goals\nThe main goals of this lab were to use a time-multiplexing schematic to drive 2 separate 7 segement LED displays with a single set of pins on the FPGA and Verilog code. In addition, a transistor was required to use in order to drive larger currents from the FPGA pins to power the LED displays. An additional LED display was also used to report the sum of the 2 7 segement LED displays in binary format. Finally, a function testbench needed to be created in ModelSim to test the System Verilog code and ensure that each of the modules created worked as expected.\n\n## Design Approach\n\n### System Verilog Design\nThe System Verilog code created consisted of an oscillator submodule that would return alternating values used to turn the transistors on and off. This submodule utilized an internal high speed oscillator running at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. These alternating bits are inputed into a mux that will output the desired switch input used between the two switch inputs assigned to the board. This desired switch input will then be fed into the sevenSeg display code used in Lab 1 that will output the desired values to the 7 segment displays. \n\n![Block diagram of System Verilog Modules](images/lab2blockdiagram.png)\n\n### 7 Segment Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode's current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor's output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n\n![Calculation to find the resistor value for the 7 segment display](images/resistor.png)\n\n### Transistor Circuit Design\nBecause the LED display used was a common anode display, a PNP transistor was needed in order to drive the current high. The emitter of the circuit was connected to the FPGA pin that oscillated between low and high values determining whether or not the circuit was turned on. When values were low, current from the base voltage would be high and flow through the LED load to turn it on. A base resistor was needed to connect the 3.3 V to the base of the transistor so that not too much current is drawn from the FPGA pins. The calculated resistor value needed for the base was 130 Ohms, but 150 Ohms was used instead since that was readily available from the stockroom.\n\n\n![Calculation to find the resistor value for the transistor](images/transistor.png)\n\n### LED Sum Circuit Design\nThe LED display used was grounded with 220 Ohm resistors for the same reason the seven segment display was. The input of this circuit was the output of combinational logic written in System Verilog. \n\n### Pin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\n| variable       | pin # |\n|----------------|:------|\n| s1[0]          |   37  |   \n| s1[1]          |   31  |  \n| s1[2]          |   35  |\n| s1[3]          |   32  | \n| s2[0]          |   11  |   \n| s2[1]          |   19  |  \n| s2[2]          |   21  |\n| s2[3]          |   10  |  \n| ledDisplay[0]  |   46  |   \n| ledDisplay[1]  |   45  |  \n| ledDisplay[2]  |   3   | \n| ledDisplay[3]  |   44  |  \n| ledDisplay[4]  |   9   | \n| seg[0]         |   47  |  \n| seg[1]         |   2   |\n| seg[2]         |   13  |  \n| seg[3]         |   20  |\n| seg[4]         |   18  |  \n| seg[5]         |   12  |\n| seg[6]         |   48  |\n| selector1      |   6   |\n| selector2      |   4   |\n\n: Pin assignment to System Verilog variables\n\n\n![Physical Circuit Schematic for Entire System](images/lab2schematic.jpg)\n\n\n## Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules's functionality. \n\n### Oscillator Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 1 timestep. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 1 M ns. When looking at the output of the testbench in the Wave view, it shows that the output of the oscillator changes value every 10000 ns, while the internal clock is oscillating at a much faster rate as expected.\n\n![Testbench output for Oscillator module](images/osctb.png)\n\n### Mux Testing\nIn order to check if the mux function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the mux function. At the start of the simulation, input values for switch inputs 1 and 2 were set to 8 and 0 respectively. A selector was then set to 1 so that the first switch value was chosen. A separate variable containing the expected output was created so that it can be compared with the output of the mux. After 2 more clock signals, the selector's value was changed to 0 so that the output of the mux is changed as well. In the simulation's Wave view, the output of the mux (s) and the expected value of the mux (s_expected) match each other's values.\n\n![Testbench output for Mux module](images/muxtb.png)\n\n### Sum Testing\nIn order to check if the sum function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for switch 1 and 2 were set to various values, along with a new variable that was the expected sum of the two switch inputs. After running the simulation for 2 clock signals, the input values of the switches and the expected sum were updated to different values. In the simulation's Wave view, it can be seen that the expected sum value matched the output of the sum module as desired. Thus, the module behaved as expected.\n\n![Testbench output for Sum module](images/sumtb.png)\n\n### Seven Segment Display Testing\nIn order to check if the Seven Segement display function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for the switch were set to various values. The expected segment display were also set. After running the simulation for 2 clock signals, the input values of the switch and the expected output were updated to different values. In the simulation's Wave view, it can be seen that the expected display value matched the output of the sevenSeg module as desired. Thus, the module behaved as expected.\n\n![Testbench output for Seven Segment Display module](images/sevenSegtb.png)\n\n\n## Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements.\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Lab 2: Multiplexed 7-Segment Display","author":"Audrey Vo","date":"9/9/2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}