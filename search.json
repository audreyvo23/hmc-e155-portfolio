[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 6 Reflection\n\n\n\n\n\nThe Internet of Things and Serial Peripheral Interface\n\n\n\n\n\nOct 22, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nFall Break Reflection\n\n\n\n\n\nPlanning Our Final Project\n\n\n\n\n\nOct 18, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Reflection\n\n\n\n\n\nInterrupts\n\n\n\n\n\nOct 8, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3.5 Blog\n\n\n\n\n\nKeypad Scanner Continued\n\n\n\n\n\nOct 8, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Reflection\n\n\n\n\n\nDigital Audio\n\n\n\n\n\nSep 9, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 Reflection\n\n\n\n\n\nKeypad Scanner\n\n\n\n\n\nSep 9, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 Reflection\n\n\n\n\n\nMultiplexed 7-Segment Display\n\n\n\n\n\nSep 9, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1 Reflection\n\n\n\n\n\nFPGA and MCU Setup and Testing\n\n\n\n\n\nSep 5, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Blog Post\n\n\n\n\n\nMy Learning Goals for this Class\n\n\n\n\n\nAug 27, 2024\n\n\nAudrey Vo\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! My name is Audrey and I’m a current Engineering student at Harvey Mudd College.\nCurrently, I’m an APISPAM Head Sponsor, Atwood Dorm President, and Machine Shop Proctor at Harvey Mudd. The past few summers, I have been able to participate in summer research with Prof. Dodds in “Summer Start-Up” and with Prof. Gokli as part of the Riggs Fellowship. I was previously HMC 2025 Class President and also a member of the Prisoner Education Project.\nI’m currently a resident of Southern California, and have lived here my entire life. (If you have any recommendations of things to do in CA, please let me know!). In my free time, I love to play pickleball, try new foods, and spend time with friends.\nIf you are interested in learning more about me, please feel free to connect on LinkedIn."
  },
  {
    "objectID": "posts/lab3.5blog.html",
    "href": "posts/lab3.5blog.html",
    "title": "Lab 3.5 Blog",
    "section": "",
    "text": "I used this week as a break to familiarize myself with Lab 4 since I had already completed Lab 3. It was kind of nice to have that break after a tough week, and use that extra time to either catch up with work from other classes or spend time with my friends. As I’m getting closer to that halfway mark with MicroPs, I think it’s funny how much mental space I spend thinking about this class. At the end of the day, this class is an elective that I don’t technically need to graduate. And yet, it’s been a pattern for me to sometimes neglect the work from other classes in return for more lab time.\nAt times, I’ve found this behavior to be a blessing and a curse. It shows that I care about the class, and am determined to get the work done. Even though it may not seem like it most of the time, I do enjoy the work we have been given and think that it is very rewarding. On the other hand, I’ve never seen myself be so fixated on a task and wonder how this behavior translate to other parts of my life. For example, when I leave college, will I be able to balance out a strong social network with my professional career? At what point do I put my work aside, and at what times should I lock-in and continue to focus on professional progress? I don’t think my relationships with people have deteriorated in any way from this class, but it’s interesting how my behavior has shifted in the presence of this class."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "First Blog Post",
    "section": "",
    "text": "First post (yayyyy!): This semester I’m excited yet terrified to be taking MicroPs. The reason I want to take this class is because I really enjoyed the E85 Labs and felt like I learned a lot from completing the work. Even though these labs were time intensive and challenging, I did feel very rewarded once it was finished and felt more confident about digital systems leaving the class. After talking to many people who have already taken E155, I do believe there is a lot more knowledge for me to gain after completing the curriculum and I’m curious to see what thsi semester has in store. I know that this class is very unique in how its set up along with the depth of content, so I know that an opportunity to take this class will be very difficult to come across again.\nFrom this class, I hope to feel very confident about approaching digital systems in the real world and be more fluent in what I learned from E85. I also hope to improve my debugging skills, whether that’s the process of how I debug or my natural intuition. Finally, I hope that I am able to understand how to persevere through challenging struggles using sheer grit. In whatever field I decide to pursue in the future, I know that learning how to push through problems will be important to my success."
  },
  {
    "objectID": "posts/lab5blog.html",
    "href": "posts/lab5blog.html",
    "title": "Lab 5 Reflection",
    "section": "",
    "text": "This week was a pretty exciting week for me in my E155 career. Ever since we have been enrolling for the class, Victoria and I have been brainstroming potential final project ideas. My previous first choice was animated Harry Potter wands that could project images based on the pattern that it is waved. However, this was always a backburner because I don’t think Victoria shared the same enthusiasm as I did for this project.\nBut this week that all changed as I was studying with her in Platt. I was inspired by our Lab 4 results and the excitement I got from being able to generate digital audio, and wondered if there was ways we could produce more complex music. That’s when the idea of making a DJ deck struck me. Victoria immediately shared great excitement when I told her about that idea, and I then knew we had a winner. For context, both Victoria and I have played around with DJing amateurly with the dream of one day being able to perform for a huge party before we graduate. I think that this project could the ticket to our dream.\nI’m excited to see what our project can produce, and hope that we’ll be mixing some sick beats in the digital lab."
  },
  {
    "objectID": "posts/fallbreakblog.html",
    "href": "posts/fallbreakblog.html",
    "title": "Fall Break Reflection",
    "section": "",
    "text": "This past week I was on fall break, and used part of this break to plan out how we were going to implement our final project. Victoria and I spent the last morning of our break at the Mudd Cafe reading past projects that also used audio to see if we could use some of their implementation ideas. The Audio Synthesizer, ATLAS Project, and microphone -&gt; audio project were the most helpful. After doing some of this research, we were both more nervous and excited for this final project. On one hand, were we biting off more than we can chew for the project? But on the other hand, how cool would it be if we could end the semester with a really cool DJ show for our friends?\nI think Victoria and I will be getting a lot of quality time together this semester.\nAfter doing our own personal research and reading about past projects, this did make me appreciate past Demo Days more. I had already thought that past projects were really cool, but this made me even more impressed now that I have a better understanding of how these projects were actually implemented. In the meantime, I think Vic and I are going to be youtubing homemade DJ decks and hoping that future labs will help us better understand data transfer (ex. how to implement SPI). This project is definitely going to present a new fun challenge for us that we haven’t had as much with the labs: how to create our own design as opposed to just implementing.\nUntil next week . . ."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Number of Hours Spent on Lab: 20 hours\nGitHub Lab 3 Files"
  },
  {
    "objectID": "labs/lab4/lab4.html#main-goals",
    "href": "labs/lab4/lab4.html#main-goals",
    "title": "Lab 4: Digital Audio",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goals of this lab was to drive a speaker from the MCU by enabling the I/O pins. In order to do so, the timer functionality needed to be implemented in order to create a square wave at the desired frequency/pitch and also indicate how long each note should be played for. Finally, a library from C needed to be written from scratch for the Timer to be implemented, which required getting familiar with the datasheet."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-approach",
    "href": "labs/lab4/lab4.html#design-approach",
    "title": "Lab 4: Digital Audio",
    "section": "Design Approach",
    "text": "Design Approach\n\nDelay Duration Design\nIn order to design the code for the delay, there were 2 functions written. One function intialized the delay timer, while the other function would use a timer to delay the code to the desired number of milliseconds. The value of the prescalar was sent to 39 in order to get a counting clock frequency of 100 kHz since the system’s clock is at 4 MHz when it is set to the default MSI. The counter was also enabled and set to 0 during initialization.\n\n\n\nCalculation to find the prescalar value for the timer\n\n\nNext, the delay function took in a pointer to a timer along with the desired delay time. This function first set the auto-reload register to 100*input delay in order to get the desired maximum counting value before resetting when the counting clock frequency is at 100 kHz. Next, the Counter and Capture/Compare 1 Interrupt flag values were set to 0. A while loop was then created to keep running until the Capture/Compare Interrupt flag is turned on, which is when the counter has a greater value than the ARR register.\n\n\n\nCalculation to find the ARR value for the delay function\n\n\nUsing the equations for the arr value, the maximum and minimum delay values could be found by using the maximum and minimum values that the auto-reload register could hold.\n\n\n\nCalculation to find the maximum delay duration\n\n\n\n\n\nCalculation to find the minimum delay duration\n\n\n\n\nPulse Width Modulator Design\nThe PWM design consisted of a function that initialized the PWM timer and a function that produced a square wave at the desired frequency. In the initialization funtion, the prescalar was also set to 39 in order to get a counting clock frequency of 100 kHz. The 100 kHz counter clock frequency ensured that our pitch output would remain within 1 percent of the desired pitch for frequencies between 220 and 1000 Hz.\n\n\n\nCalculation to verify the accuracy of the output frequency\n\n\nIn addition, the auto-reload preload enable was set so that the ARR register is buffered. The Output Compare 1 Mode bits were set also set so that the PWM mode is set. The Capture Compare 1 Output enable and the Main Output Enable were also turned on so. Finally, the update generation was set so that the counter is reinitialized and the registers are updated. Lastly, the counter is then enabled for the timer. The output of this function was set to an alternate function in order to connect the timer value with the GPIO pins.\nFor the setPitch function, the ARR register was set to 100000/inputfrequency in order to get the desired number of counts for one period of the square wave. Knowing the maximum and minimum ARR values along wtih its relationship to the input frequency, the maximum and minimum frequency ranges can be calculated.\n\n\n\nCalculation to find the ARR register value for the PWM output\n\n\n\n\n\nCalculation to find the maximum frequency\n\n\n\n\n\nCalculation to find the minimum frequency\n\n\nThe update generation was set so that the counter is reinitialized and the registers are updated. Lastly, the counter is then enabled for the timer.\n\n\nCircuit Design\nThe circuit created consisted of a 10k potentiometer that took in the output of the PWM output and inputted the voltage drop into the LM386N amplifier. The LM386N was configured so that no gain was used, and its output was fed into the an 8 Ohm speaker. This configuration allowed for the volume to be controlled by adjusting the potentiometer and to limit current drawn from the GPIO pins.\n\n\nPin Assignment\n\nPin assignment to MCU C Code\n\n\nvariable\npin #\n\n\n\n\nTIM16\nA6\n\n\nTIM15\nA9\n\n\n\n\n\n\nFull schematic with Led, Switch, and 7-segment display pin connections"
  },
  {
    "objectID": "labs/lab4/lab4.html#finished-lab",
    "href": "labs/lab4/lab4.html#finished-lab",
    "title": "Lab 4: Digital Audio",
    "section": "Finished Lab",
    "text": "Finished Lab"
  },
  {
    "objectID": "labs/lab4/lab4.html#testing-approach",
    "href": "labs/lab4/lab4.html#testing-approach",
    "title": "Lab 4: Digital Audio",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, I used an oscilloscope to measure the frequency of the output pitch and the output delay. If the delay was set to 10 ms, the frequency output is expected to be 50 Hz. Using the oscilloscope, this was the value I measured. For the output frequency, I set the pitch to a value of 250 Hz, and measured the output of the timer pin. As expected, I saw a value at about 248 Hz, which matches very closely to the 250 Hz. Thus, my circuit worked as desired."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-requirements",
    "href": "labs/lab4/lab4.html#design-requirements",
    "title": "Lab 4: Digital Audio",
    "section": "Design Requirements",
    "text": "Design Requirements\nAfter testing the design on the oscilloscope and in real-life, I can confirm the design meets all specs."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Number of Hours Spent on Lab: 11 hours\nGitHub Lab 2 Files"
  },
  {
    "objectID": "labs/lab2/lab2.html#main-goals",
    "href": "labs/lab2/lab2.html#main-goals",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goals of this lab were to use a time-multiplexing schematic to drive 2 separate 7 segement LED displays with a single set of pins on the FPGA and Verilog code. In addition, a transistor was required to use in order to drive larger currents from the FPGA pins to power the LED displays. An additional LED display was also used to report the sum of the 2 7 segement LED displays in binary format. Finally, a function testbench needed to be created in ModelSim to test the System Verilog code and ensure that each of the modules created worked as expected."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-approach",
    "href": "labs/lab2/lab2.html#design-approach",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design Approach",
    "text": "Design Approach\n\nSystem Verilog Design\nThe System Verilog code created consisted of an oscillator submodule that would return alternating values used to turn the transistors on and off. This submodule utilized an internal high speed oscillator running at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. These alternating bits are inputed into a mux that will output the desired switch input used between the two switch inputs assigned to the board. This desired switch input will then be fed into the sevenSeg display code used in Lab 1 that will output the desired values to the 7 segment displays.\n\n\n\nBlock diagram of System Verilog Modules\n\n\n\n\n7 Segment Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode’s current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor’s output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n\n\nCalculation to find the resistor value for the 7 segment display\n\n\n\n\nTransistor Circuit Design\nBecause the LED display used was a common anode display, a PNP transistor was needed in order to drive the current high. The emitter of the circuit was connected to the FPGA pin that oscillated between low and high values determining whether or not the circuit was turned on. When values were low, current from the base voltage would be high and flow through the LED load to turn it on. A base resistor was needed to connect the 3.3 V to the base of the transistor so that not too much current is drawn from the FPGA pins. The calculated resistor value needed for the base was 130 Ohms, but 150 Ohms was used instead since that was readily available from the stockroom.\n\n\n\nCalculation to find the resistor value for the transistor\n\n\n\n\nLED Sum Circuit Design\nThe LED display used was grounded with 220 Ohm resistors for the same reason the seven segment display was. The input of this circuit was the output of combinational logic written in System Verilog.\n\n\nPin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\nPin assignment to System Verilog variables\n\n\nvariable\npin #\n\n\n\n\ns1[0]\n37\n\n\ns1[1]\n31\n\n\ns1[2]\n35\n\n\ns1[3]\n32\n\n\ns2[0]\n11\n\n\ns2[1]\n19\n\n\ns2[2]\n21\n\n\ns2[3]\n10\n\n\nledDisplay[0]\n46\n\n\nledDisplay[1]\n45\n\n\nledDisplay[2]\n3\n\n\nledDisplay[3]\n44\n\n\nledDisplay[4]\n9\n\n\nseg[0]\n47\n\n\nseg[1]\n2\n\n\nseg[2]\n13\n\n\nseg[3]\n20\n\n\nseg[4]\n18\n\n\nseg[5]\n12\n\n\nseg[6]\n48\n\n\nselector1\n6\n\n\nselector2\n4\n\n\n\n\n\n\nPhysical Circuit Schematic for Entire System"
  },
  {
    "objectID": "labs/lab2/lab2.html#testing-approach",
    "href": "labs/lab2/lab2.html#testing-approach",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules’s functionality.\n\nOscillator Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 1 timestep. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 1 M ns. When looking at the output of the testbench in the Wave view, it shows that the output of the oscillator changes value every 10000 ns, while the internal clock is oscillating at a much faster rate as expected.\n\n\n\nTestbench output for Oscillator module\n\n\n\n\nMux Testing\nIn order to check if the mux function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the mux function. At the start of the simulation, input values for switch inputs 1 and 2 were set to 8 and 0 respectively. A selector was then set to 1 so that the first switch value was chosen. A separate variable containing the expected output was created so that it can be compared with the output of the mux. After 2 more clock signals, the selector’s value was changed to 0 so that the output of the mux is changed as well. In the simulation’s Wave view, the output of the mux (s) and the expected value of the mux (s_expected) match each other’s values.\n\n\n\nTestbench output for Mux module\n\n\n\n\nSum Testing\nIn order to check if the sum function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for switch 1 and 2 were set to various values, along with a new variable that was the expected sum of the two switch inputs. After running the simulation for 2 clock signals, the input values of the switches and the expected sum were updated to different values. In the simulation’s Wave view, it can be seen that the expected sum value matched the output of the sum module as desired. Thus, the module behaved as expected.\n\n\n\nTestbench output for Sum module\n\n\n\n\nSeven Segment Display Testing\nIn order to check if the Seven Segement display function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the sum function. At the start of the simulation, input values for the switch were set to various values. The expected segment display were also set. After running the simulation for 2 clock signals, the input values of the switch and the expected output were updated to different values. In the simulation’s Wave view, it can be seen that the expected display value matched the output of the sevenSeg module as desired. Thus, the module behaved as expected.\n\n\n\nTestbench output for Seven Segment Display module"
  },
  {
    "objectID": "labs/lab2/lab2.html#design-requirements",
    "href": "labs/lab2/lab2.html#design-requirements",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design Requirements",
    "text": "Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Number of Hours Spent on Lab: 20 hours\nGitHub Lab 6 Files"
  },
  {
    "objectID": "labs/lab6/lab6.html#main-goals",
    "href": "labs/lab6/lab6.html#main-goals",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goal of this lab was to implement the SPI functionality of the MCU and interface with a temperature over an SPI link. The ESP8266 was also interfaced with the MCU over a UART link to toggle an LED on the board and display the output of the temperature sensor. These results were written on an HTML page, and allows the user to update the resolution of the temperature data displayed. Finally, a logic analyzer functionality on the oscilloscope was used to help measure outputs of the SPI data communication, and assist in any debugging."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-approach",
    "href": "labs/lab6/lab6.html#design-approach",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design Approach",
    "text": "Design Approach\n\nSPI Design\nIn order to design the code for the SPI, it first needed to be initialized on the MCU. The SPI’s baud rate was set to 625 kHz in order to run slower than the clock of the temperature sensor. In addition, the data size for the communication was set to 8 bits in order to align with the data output of the sensor.\nA separate function was then created to transmit a byte over SPI and return its received character. This would write 8 bits of data to the data register when the transmit buffer register is empty, and return its received character when the receive buffer is no longer empty.\nWhen using SPI for the temperature sensor, it would be configured to a specific resolution based on the user input from the HTML webpage. The chip enable for the sensor was set to a GPIO output pin that would be toggled on only when SPI was transmitting data and off otherwise. Two SPI function calls were used for each read and write of the temperature sensor. When writing data, the call would first go to the write address of the temperature sensor, and then followed with the configuration information that includes the desired resolution. There were two different times needed for reading the data bits. This is because the read data from the temperature sensor is 16 bits, so it was split up into two 8-bit read calls for the MSB and LSB. Some conversion was then performed on these bits to properly display the temperature as a positive or negative number.\n\n\nHTML Web Page Design\nThe HTML web page contained two separate forms. One to toggle the LED on and off, and the other to determine the resolution of the temperature sensor. Depending on what the person selects, the resolution of the temperature output would update on the webpage. The information given to the webpage would interact with the ESP8266 in order to wirelessly connect with the MCU code by using GET requests.\n\n\nCircuit Design\nThe circuit created consisted of an MCU, ESP8266, and DS1722 Digital Thermometer.\n\n\nPin Assignment\n\nPin assignment to MCU C Code\n\n\nvariable\npin #\n\n\n\n\nSCLK\nA5\n\n\nMISO\nA6\n\n\nCSS\nA8\n\n\nTX\nA9\n\n\nRX\nA10\n\n\nMOSI\nA12\n\n\nLED\nB3\n\n\n\n\n\n\nFull schematic with MCU, DS1722 Temperature Sensor, and ESP8266"
  },
  {
    "objectID": "labs/lab6/lab6.html#testing-approach",
    "href": "labs/lab6/lab6.html#testing-approach",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, I used both the logical analyzer and debugger window. I used the logic analyzer to check if a clock signal, chip select, and the MISO and MOSI lines were sending a signal. I then checked what the values were of the MISO line to see if the value being being read seemed reasonable to the room temperature. I then used my finger to touch the sensor, and check if the temperature reading would increase when my finger was touching it and decrease when I released my finger. As you can see in the image below, the MISO line reads 16 in Hex which equals 22 degrees Celsius. This is a reasonable tempearture to be recording since it is about room temperature.\n\n\n\nLogic Analzyer Reading of SPI communication with DS1722\n\n\nI then used the debugger window to print the values that were read from the temperature sensor to see if they were properly converted into integer values of the correct resolution."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-requirements",
    "href": "labs/lab6/lab6.html#design-requirements",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design Requirements",
    "text": "Design Requirements\nAfter testing the design on the oscilloscope and in real-life, I can confirm the design meets all specs."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Number of Hours Spent on Lab: 14 hours\nGitHub Lab 1 Files"
  },
  {
    "objectID": "labs/lab1/lab1.html#main-goals",
    "href": "labs/lab1/lab1.html#main-goals",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goals of this lab was to assemble the development board and test out the MCU and FPGA boards. In addition, an FPGA design was created in System Verilog to control 3 LEDs on the board and a 7-segement display. The LEDs and 7-segement display behavior is based on input of the switches on the board. As a result, the 7-segment display needed to be interfaced to the FPGA board in order to work as desired."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-approach",
    "href": "labs/lab1/lab1.html#design-approach",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design Approach",
    "text": "Design Approach\n\nLED Design\nIn order to design the project so that the LEDs worked properly, I recognized that one of the led[1] is controlled by an AND gate and the second led[0] is controlled by an XOR gate of the switch values. Led[2] needed to blink at 2.4 Hz using an internal high-speed oscillator. By using the starter code provided in the fpga_dev_board_test file, a new maximum counter value needed to be calculated. Since the internal oscillator is running at 48 MHz, we get the number of counts to be 10M to get an led blinking at 2.4 MHz assuming we want a 50% duty cycle. An additional variable needed to be created in order to check if the led should be turned on or off every time the counter gets to 10M.\n\n\n\nCalculation to find the number of counts\n\n\n\n\n7 Segment Display Design\nIn order to design the 7-segment display, I had to use a series of case statement for the 16 different outputs to be displayed based on the switches in a separate submodule. It was important to set pin 3 on the display to the 3.3 V so that it is always on. Thus, the segement’s cathode will turn the segement on when it is set to 0. Each case statement set the output segement values to 0 when that segement should be turned on based on what binary value was currently set on the input switches. This code was written in a separate file but was called in the same file that controlled the 3 Leds. In order to wire the 7-segment display, the various pins that controlled the display were connected to the FPGA board using 240 Ohm resistors in order to achieve 10 mA of current.\n\n\n\nCalculation to find the resistor value for the 7 segment display\n\n\n\n\n\nBlock Diagram of System Verilog module\n\n\n\n\nPin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the switches, Leds, and 7-segment display on the board. The s, seg, and led variables defined in System Verilog were assigned to physical pins on the board shown as the following:\n\nPin assignment to System Verilog variables\n\n\nvariable\npin #\n\n\n\n\ns[0]\n37\n\n\ns[1]\n31\n\n\ns[2]\n35\n\n\ns[3]\n32\n\n\nled[0]\n42\n\n\nled[1]\n38\n\n\nled[2]\n28\n\n\nseg[0]\n47\n\n\nseg[1]\n2\n\n\nseg[2]\n13\n\n\nseg[3]\n20\n\n\nseg[4]\n18\n\n\nseg[5]\n12\n\n\nseg[6]\n48\n\n\n\n\n\n\nFull schematic with Led, Switch, and 7-segment display pin connections"
  },
  {
    "objectID": "labs/lab1/lab1.html#testing-approach",
    "href": "labs/lab1/lab1.html#testing-approach",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. The values of input s can be forced to any binary combination, and the output from the code could be seen in the Wave view. Upon doing so, I could see that the output I was receving from the forced inputs were the desired values. A testbench was also created to check that there were no errors in my logic.\nFinally, I uploaded the code to my FPGA board, which was also connected to the 7-segment display through a ribbon cable. After toggling with the physical input switches, the desired led behavior and 7-segment display was shown. I also used an oscilloscope to measure the frequency of the third led to ensure it had the desired frequency of 2.4 Hz.\n\n\n\nTestbench output for the circuit"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-requirements",
    "href": "labs/lab1/lab1.html#design-requirements",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design Requirements",
    "text": "Design Requirements\nAfter testing the design on both ModelSim and physically, I can confirm that it meets all the requirements."
  },
  {
    "objectID": "labs/lab7/images/lab1.html",
    "href": "labs/lab7/images/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! My name is Audrey and I’m a current Engineering student at Harvey Mudd College.\nCurrently, I’m an APISPAM Head Sponsor, Atwood Dorm President, and Machine Shop Proctor at Harvey Mudd. The past few summers, I have been able to participate in summer research with Prof. Dodds in “Summer Start-Up” and with Prof. Gokli as part of the Riggs Fellowship. I was previously HMC 2025 Class President and also a member of the Prisoner Education Project.\nI’m currently a resident of Southern California, and have lived here my entire life. (If you have any recommendations of things to do in CA, please let me know!). In my free time, I love to play pickleball, try new foods, and spend time with friends.\nIf you are interested in learning more about me, please feel free to connect on LinkedIn."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Number of Hours Spent on Lab: 12 hours\nGitHub Lab 5 Files"
  },
  {
    "objectID": "labs/lab5/lab5.html#main-goals",
    "href": "labs/lab5/lab5.html#main-goals",
    "title": "Lab 5: Interrupts",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goals of this lab was to use the MCU to be able to display the velocity and direction of a motor by detecting the quadrature encoder pulses as an input. A multi-interrupt routine was implemented for the pulses returned by the encoder. This allowed for a velocity and direction to then be calculated by the results of the interrupt functions."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-approach",
    "href": "labs/lab5/lab5.html#design-approach",
    "title": "Lab 5: Interrupts",
    "section": "Design Approach",
    "text": "Design Approach\n\nInterrupt Design\nIn order to design the code for the interrupts, a separate function for the Interrupt Handler was written in the main file. An External Interrupt was used to trigger the interrupt on the falling edge for the two different pulses outputted by the encoder. The two pulses were taken as an input to the MCU’s GPIO pins. A global variable was created that was updated with the time difference between the falling and rising edges of the two inputs. The time difference was found by using a timer that counts at a speed of 1 MHz between when the interrupts are triggered. A separate timer was also created at 1 kHz to delay the printing of the motor speeds. The speed of the motor can then be found since the difference between the falling edge of the two inputs is known to be 1/4 of a pulse.\nWe could determine the direction that the motor was spinning by checking if the A and B signal were both high or both low when it was triggered on which signal’s pulse edge. If both the A and B signal were on or off on the clock edge of the ASIGNAL, the direction the motor is moving is counter-clockwise. If both the A and B signal were on or off on the clock edge of the BSIGNAL, the direction the motor is moving is clockwise. When the A and B signal are both on or off on the pulse edge of either signals, the timer count value will then be used to update the speed of the motor. At every clock edge interrupt, the timer is reset to 0 to ensure that the timer value represents 1/4 of the pulse.\n\n\n\nCalculation to determine the speed of the motor\n\n\n\n\n\nFlowchart of Interrupt Design\n\n\n\n\nCircuit Design\nThe circuit created consisted of an MCU, motor, and quadrature encoder. The pins used for this lab from MCU as inputs were verified to be 5V tolerant, and the motor was being driven by a 12V external power supply. The pins for the qudrature encoder signals were directly connected to the MCU input.\n\n\nPin Assignment\n\nPin assignment to MCU C Code\n\n\nvariable\npin #\n\n\n\n\nASIGNAL\nA5\n\n\nBSIGNAL\nA6\n\n\n\n\n\n\nFull schematic with motor, quadrature encoder, and power supply"
  },
  {
    "objectID": "labs/lab5/lab5.html#testing-approach",
    "href": "labs/lab5/lab5.html#testing-approach",
    "title": "Lab 5: Interrupts",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, I set the power supply because I knew that the expected behavior of the motor would be 10 rev/s. I also used an oscilloscope to measure the change in time of both encoder signal’s falling edge, and then solved for the speed to make sure it matched with the speed being displayed from the interrupt code."
  },
  {
    "objectID": "labs/lab5/lab5.html#polling-vs.-interrupt-based-code",
    "href": "labs/lab5/lab5.html#polling-vs.-interrupt-based-code",
    "title": "Lab 5: Interrupts",
    "section": "Polling vs. Interrupt-Based Code",
    "text": "Polling vs. Interrupt-Based Code\nWith code that requires polling, the calculations and signal processing is done in the while loop within the main function. This can be problematic for high speed codes because each of these commands take time, while the interrupt is completed immediately. Therefore, if the code is running at high speeds, the value that polling generates may be delayed and not match the actual current expected value. In contrast, interrupts will complete the set of commands immediately, and the next line of code of will not be executed until that command is completed. Thus, we are guaranteed with interrupts that the the results generated will be up to date and accurate."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-requirements",
    "href": "labs/lab5/lab5.html#design-requirements",
    "title": "Lab 5: Interrupts",
    "section": "Design Requirements",
    "text": "Design Requirements\nAfter testing the design on the oscilloscope and in real-life, I can confirm the design meets all specs."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Number of Hours Spent on Lab: 30 hours\nGitHub Lab 3 Files"
  },
  {
    "objectID": "labs/lab3/lab3.html#main-goals",
    "href": "labs/lab3/lab3.html#main-goals",
    "title": "Lab 3: Keypad Scanner",
    "section": "Main Goals",
    "text": "Main Goals\nThe main goals of this lab were to use design and implement and circuit interface on the FPGA that read a keypad matrix. This required creating a solution to address issues that arose from switch bouncing. Finally, the last 2 inputted digits needed to be displayed on a pair of 7 segment LED displays."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-approach",
    "href": "labs/lab3/lab3.html#design-approach",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design Approach",
    "text": "Design Approach\n\nFSM Design\nIn order to detect which row and column were turned on during a button pressed, all of the rows could not be turned on at once because then several keys would be viewed as on with a single button press. Thus, the idea was to scan through the rows during each clock cycle, and then take the columns as an input to the FPGA. Whenever a column is detected on, the FPGA can then figure out which row was powered on that time and then decode the corresponding key value.\nAn FSM was created to keep track of all of the states. States 0, 1, 2, and 3 are cycled through when the button is off, until a button is turned on. The button is turned on when any of the column inputs are detected to be on. When a button is turned on, the next state will be a separate state (represented by States 4, 6, 8, 10) that will be stayed at for one clock cycle. The enable is represented when any of these states are turned on, because it will be used later to track when the digits on the keypad need to be shifted. Finally, after the button is pressed, if it is still being pressed or held down after the first clock cycle, it will be moved to a holding state represented by States 5, 7, 9, and 11. In addition, only one button click should be detected, which is why these states exist, and the program will stay on these states until the button is turned off.\n\n\n\nTable 1: State Transition Table\n\n\n\n\n\n\n\n(a) Current State\n\n\n\n\n\nCurrent State\n\n\n\n\nS0\n\n\nS1\n\n\nS2\n\n\nS3\n\n\nS4\n\n\nS5\n\n\nS6\n\n\nS7\n\n\nS8\n\n\nS9\n\n\nS10\n\n\nS11\n\n\n\n\n\n\n\n\n\n\n\n(b) Next State\n\n\n\n\n\nB = 1\nB = 0\n\n\n\n\nS10\nS1\n\n\nS4\nS2\n\n\nS6\nS3\n\n\nS8\nS0\n\n\nS5\nS1\n\n\nS5\nS1\n\n\nS7\nS2\n\n\nS7\nS2\n\n\nS9\nS3\n\n\nS9\nS3\n\n\nS11\nS0\n\n\nS11\nS0\n\n\n\n\n\n\n\n\n\n\n\n(c) Output\n\n\n\n\n\nB = 1\n\n\n\n\n\nR0 = 1\n\n\n\nR1 = 1\n\n\n\nR2 = 1\n\n\n\nR3 = 1\n\n\n\nR1 = 1\nen = 1\n\n\nR1 = 1\n\n\n\nR2 = 1\nen = 1\n\n\nR2 = 1\n\n\n\nR3 = 1\nen = 1\n\n\nR3 = 1\n\n\n\nR0 = 1\nen = 1\n\n\nR0 = 1\n\n\n\n\n\n\n\n\n\n\n\n\n//See Table 1 for details, especially Table 1 (c).\n\n\n\nFSM Diagram for the Key Scanner\n\n\n\n\nSystem Verilog Design\nThe System Verilog code created consisted of an internal high speed oscillator at 2.4kHz, so that the values displayed on the LED are going fast enough that it looks like the values are being displayed simultaneously. This same clock was also used for the keypad_scanner, two_digit_mem, and selector_checker.\nThe keypad_scanner submodule took in the column inputs of the physical keypad and outputted an 8 bit value that represented which rows and columns were turned on at each clock cycle. A counter was also outputted that counted for 50 clock cycles to represent what values should count as an actual button press as opposed to switch bouncing. Finally, an enable was also outputted that represented when each button was turned in the form of one clock cycle.\nThe 8 bit value outputted from the keypad_scanner was then inputted to another submodule known as keypad_decoder taht return a 4 bit value representing the desired hex value that should be displayed on the seven segment display.\nIn order to shift the key values properly to display the last 2 values pressed on the keypad, a shifting submodule was created. This submodule would shift the key values at every clock edge only if the enable was high (button is on for exactly one clock cycle) and if the counter was greater than 50 clock cycles. This ensured that there was no switch bouncing and also that the the keypad values were be shifted for only one clock cycle. This submodule would then output the two desired hex values that should be displayed on the seven segment display.\nSystem Verilog code for how the two values were displayed on the sevenSeg were used from Lab 2.\n\n\n\nBlock diagram of System Verilog Modules\n\n\n\n\n7 Segment and Transistor Circuit Design\nSince there are 2 segments that will be alternating between two digits with the same set of FPGA pins, a transistor was needed to control whether each of the digits should display an LED value or if it should be turned off completely. Since the LED display used was a common anode, we could connect a PNP transistor to drive the common anode’s current to high when it is on or low when it is off. For the display, that means pins 13 and 14 were each connected to their own transistor’s output. I then connected both of the LED segments respective outputs to the same FPGA pins. The various pins that controlled the display were connected to the FPGA board using 220 Ohm resistors in order to achieve 7 mA of current.\n\n\nKeypad Circuit Design\nThe keypad consisted of 8 pins that powered the 4 rows and 4 columns. The 4 column were connected as inputs to the FPGA. They all required pull-down resistor values in order to ensure that the input was not floating. This resistor value was calculated in order to minimize the current flow to about 1.2 mA. As a result, the resistors used for the circuit are all 2.7 kOhms.\n\n\n\nCalculations to solve for pull-down resistor value\n\n\nIn addition, the 4 pins connected to the rows of the keypad acted as direct inputs to the FPGA.\n\n\nPin Assignment\nFinally, the pins from the FPGA needed to be correctly assigned to the 7-segment display and keypad pins. The column variables (C0, C1, C2, C3), reset, row variables (R0, R1, R2, R3), selectors, and 7 segment values (seg) defined in System Verilog were assigned to physical pins on the board shown as the following:\n\nPin assignment to System Verilog variables\n\n\nvariable\npin #\n\n\n\n\nseg[0]\n47\n\n\nseg[1]\n2\n\n\nseg[2]\n13\n\n\nseg[3]\n20\n\n\nseg[4]\n18\n\n\nseg[5]\n12\n\n\nseg[6]\n48\n\n\nselector1\n6\n\n\nselector2\n4\n\n\nC0\n45\n\n\nC1\n10\n\n\nC2\n19\n\n\nC3\n21\n\n\nR0\n44\n\n\nR1\n46\n\n\nR2\n9\n\n\nR3\n11\n\n\nreset\n34\n\n\n\n\n\n\nPhysical Circuit Schematic for Entire System\n\n\n\n\nTradeoffs of Chosen Design\nThe design I created involved creating a lot of modules for each of the design’s functions. This made it easy for me to test and debug each module individually, and also understand the process flow of the circuit design. However, when I was testing the modules all together, I had a lot of difficulty tracking down which module the issue would arise in because there were a lot of internal variables being passed through each module.\nAnother design choice I made was the FSM design. The FSM design was intuitive because it used a lot of the concepts we used in class such as how to get a pulse for only one clock cycle. I also understood what was happening the FSM, so it was easier for me to implement in System Verilog. However, when I was trying to implement debouncing later, it was difficult to do so within the existing FSM, since that FSM was already fully set. Thus, I was trying to create a debouncing system that did not affect or further complicate the current FSM implemented. This definitely caused some difficulty because of the design constraints."
  },
  {
    "objectID": "labs/lab3/lab3.html#testing-approach",
    "href": "labs/lab3/lab3.html#testing-approach",
    "title": "Lab 3: Keypad Scanner",
    "section": "Testing Approach",
    "text": "Testing Approach\nIn order to test the design, the System Verilog code was opened in ModelSim. A set of additional testbench files in System Verilog were created to test each of the submodules’s functionality.\n\nKeypad Scanner Testing\nIn order to check if the oscillator function was working properly, a clock signal was generated with 10 timesteps. A dut (device under test) was then instantiated calling the oscillator function. The testbench was then run for 2000 ns. At random times, one of the column inputs would be forced to 1. When looking at the output of the testbench in the Wave view, it shows the rows rotating on high every clock cycle until a column is turned on high. When the column is high, the value of the row it is set on will stay high as expected. Thus, the keypad_val outputting at this point is a combination of the columns and rows that are high.\n\n\n\nTestbench output for Keypad Scanner\n\n\n\n\nKeypad Decoder Testing\nIn order to check if the keypad decoder function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the keypad decoder function. At the start of the simulation, input values for the keypad decoder reflecting which rows and columns were currently on. The waveforms could then be observed of the output to ensure it shows the expected binary output based on the row and column inputs.\n\n\n\nTestbench output for Keypad Decoder module\n\n\n\n\nTwo Digit Memory Testing\nIn order to check if the two digit memory function was working properly, a clock signal was generated with 10 timestep. A dut (device under test) was then instantiated calling the two digit memory function. At the start of the simulation, input values for the input switch were set to various values. Some were held for less than 50 clock cycles, while others were held for longer than 50 clock cycles. The two digit memory was supposed to take care of switch bouncing, so the waveform should show the output s1 and s2 values only capturing and switching values when the input s is held for longer than 50 clock cycles. This behavior was observed in the waveforms. Thus, the module behaved as expected.\n\n\n\nTestbench output for Two Digit Memory module\n\n\n\n\nTop Module\nBefore transferring all of the code to Radiant Software, a final testbench was created for the top module that tested all of the submodules together. A dut was instantiated with the column inputs and expected output being held at various values. At one point, one of the column inputs were held for less than 50 clock cycles to test switch bouncing. The output of this waveform was the expected seven Segment output pins in binary. In the waveform, it can be seen that there are two values oscillating as expected to reflect the keypad input simulated.\n\n\n\nTestbench output for the Top Level module"
  },
  {
    "objectID": "posts/lab6blog.html",
    "href": "posts/lab6blog.html",
    "title": "Lab 6 Reflection",
    "section": "",
    "text": "This week’s lab was actually pretty enjoyable for me because I felt like I learned a lot and it eventually showed me how much I have grown since starting MicroPs. A lot of the initializing SPI was similar to what we have done, and I felt like I was able to understand how to do it much quicker than previously. However, I think something I still struggle with is being comfortable with an oscilloscope. Even after watching the tutorial to use the logic analyzer, I was confused on how to use it properly and was intimidated by the number of modes/buttons on the device. Although I am better as using this device than when I started the class, there is still plenty of room for me to improve.\nAs I’m about to enter my final lab for this class, I do feel proud of myself looking back. I definitely struggled a lot this semester, but now see a lot of the struggle as a necessary means for me to learn the amount of information I have in such a short time. There were definitely moments where I doubted my ability to complete a lot of the work assigned to us, so I’m proud of myself for still being here. I’m interested to see how Lab 7 will goes because it seems to wrap up all of the work we have been doing this semester and will connect the various lessons all together."
  },
  {
    "objectID": "posts/lab4blog.html",
    "href": "posts/lab4blog.html",
    "title": "Lab 4 Reflection",
    "section": "",
    "text": "The output of this week’s lab ended up being very enjoyable for me because it was fun to combine music with electronics and hear something pleasant at the end of this week. After I had completed the lab with my own song, I went around campus showing all of my friends a video of the finished lab and asked for them to guess what song was playing. However, the process of getting this lab was definitely grueling in a different way from previous labs. It was easy to get lost within the 1600 reference sheet and understand every register that needed to be turned on. At the start of the lab, I definitely felt overwhelmed. However, as I started to spend more hours going through the manual and recording my notes, I started to be more familiar with how to navigate this monstrosity of a document. I’m still not completely confident on knowing all of the registers, but I do feel more confident on how I can get that information.\nAs we are starting to hit the halfway mark of E155, I have been brainstorming different ideas for the final project. One idea that sparked from this lab is making a more complicated audio system that has different features. My prospective partner and I both got into DJing a little bit last year, and thought it would be really cool if we could somehow implement a basic version of a DJ deck with features such as gain control, filters, and different audios playing at once. I’d obviously want to get more feedback on this idea to understand its feasibility within the the second half of this class, but am excited where this line brainstorming will end up!"
  },
  {
    "objectID": "posts/lab1blog.html",
    "href": "posts/lab1blog.html",
    "title": "Lab 1 Reflection",
    "section": "",
    "text": "This lab was a great introduction for the class because a lot of the content of assembly and system verilog code was content I had learned from E85. Since it has been a year since I have taken the class, it did take me some time to go through my E85 notes and recall some of the syntax used. One new thing about this lab was definitely using GitHub. I have used GitHub once before in CS70, but the repositories were pre-made for us and easily cloned. Thus, it was definitely difficult for me at first to use, and even now I am still not completely confident on pushing/branching. I hope that this hesitancy will start to go away as I get more practice using GitHub for future labs.\nFrom this lab, I think I’m starting to understand the perseverance and grit needed to get through MicroPs. Up until this semester, I had only heard a series of horror stories from MicroP alums, so I was very unsure if I could handle the workload this class supposedly would induce. Now that I have finished my first class, I can now personally confirm that the horror stories I had heard are true. However, I do think that the workload could possibly be managed if I keep the following thoughts in mind:\n\nAsk for help when needed.\nTake a break when stressed and then come back later.\nStruggling is unfortunately a part of the learning process."
  },
  {
    "objectID": "posts/lab3blog.html",
    "href": "posts/lab3blog.html",
    "title": "Lab 3 Reflection",
    "section": "",
    "text": "This lab was one of the most challenging labs I have done in my life. Before starting, I was forewarned by some tutors and now understand why. I do feel accomplished for being able to get some response from the keypad, but the majority of my time was spent on thinking and debugging. In order to understand what to implement and how, I had to really think my design out and consider numerous edge cases. Because there were many moving parts and steps, this required me to try to systematically break up the problem in smaller chunks and work on each chunk before testing everything together.\nThe debugging for this lab required extensive use of ModelSim’s waveform view. The waveforms were helpful in visualizing the output of each module, and helped me track where values were exhibiting undefined behavior. Once the simulation worked for all of the modules, I then copied the code into Lattice Radiant. However, even then, there were challenges where the hardware was still not behaving as expected because the simulation and hardware are not identical. This was definitely frustrating because it made debugging a lot harder for me. I then had to rely on oscilloscoping to get a lead on where things were going wrong. From this lab overall, I learned the importance of tackling problem systematically in smaller parts as opposed to trying to figure everything out at once. I’m sure this lesson will serve me well in future labs and problems I face outside of MicroPs.\nP.S. Shoutout to Kavi for being an amazing grutor and very patient with me as I was in the trenches with the lab."
  },
  {
    "objectID": "posts/lab2blog.html",
    "href": "posts/lab2blog.html",
    "title": "Lab 2 Reflection",
    "section": "",
    "text": "In this week’s lab, I learned how to use a mux and transistor to drive 2 seven segment displays at once. Something I really struggled with during the lab was understanding how the transistor worked to control whether or not current flowed through, and why the transistor was needed. I have learned about transistors before in E84 and E85, but I had only understood it from a high level as a “switch”. I never understood how that switch would actually be implemented, so this lab forced me to do so in order for my circuit to function as desired.\nSomething I also took away from this lab was the importance of neat wiring. Since this lab required a lot of wires and circuitry, I was halfway through wiring everything up when I realized how messy the final product was going to be. As a result, a lot of wire could easily be unattached as I’m moving around the board and it would be more difficult to debug or spot. In the future, I’m going to pay more attention about planning out my board layout before I start wiring.\n\n\n\nMessy Wiring from Lab 2 :()\n\n\nFinally, I learned how to make testbenches without testvectors. Initially, I was having trouble trying to make testvectors since the output of the module would be constantly oscillating. However, after talking to the tutors, they emphasized that the point of a testbench is to ensure that the modules work as desired, and can be easily done without testvectors. This was my first time making a testbench without testvectors, and I will continue to do so for future labs."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Website"
  },
  {
    "objectID": "resources.html#helpful-links",
    "href": "resources.html#helpful-links",
    "title": "Resources",
    "section": "",
    "text": "E155 Website"
  }
]